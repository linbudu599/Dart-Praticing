# Provider 中文文档翻译

IW组件的上层封装, 使其更易用 更易复用



使用`provider`而非手动书写IW, 你会获得以下xx:

- 简化的状态配置设定与清楚 ?
- 懒加载
- 相比创建新类, 大大减少模板代码量
- 对开发者工具更为友好
- 更通用的消费IW的方式
- 提升类的可伸缩性, by监听架构所拥有的指数增长的时间复杂度



## 从 v3.x.0 迁移至 v4.0.0

- providers的builder与initialBuilder参数被移除

  - d

- 新的 create/update 回调函数是懒加载的, 也即是说他们在对应的值第一次被读取时才被调用, 而非provider首次被创建时.

  如果你不需要这个特性, 你可以通过将provider的lazy属性置为false, 来禁用懒加载

- 重命名

- 接口被移除, 并被新类型组件 替代

- Selector现在会将先后的集合类型的值进行深比较

  如果你不需要这个特性, 你可以通过给 传入 shouldRebuild参数来还原至旧有表现.

- DW及其家族被移除, 现在想要自定义provider, 直接继承IP或当前存在的provider



## 使用

### 暴露一个值

### 暴露一个新的对象实例

Providers不仅可以暴露出一个值, 也可以创建/监 听/销毁它.

要暴露一个新创建的对象, 使用一个provider的默认构造函数. 如果你想创建一个对象, 不要使用.value构造函数, 否则可能会有你预期外的副作用.

查看这个答案, 来了解更多为什么使用.value构造函数创建值是不推荐的

- 在create内创建新对象

- 不要使用创建对象

- 不要从可能发生随着时间改变的变量上创建对象

  在这种情况下, 如果变量发生变化, 你的对象将永远不会被更新



​	如果你想将随着时间改变的变量传入给对象, 考虑使用``



​	注意:

​	当使用一个provider的create/update回调时, 请注意回调函数默认是被懒调	用的.

​	也就是说, 除非这个值被读取了至少一次, 否则create/update函数不会被调用

​	如果你想预先计算一些逻辑, 可以通过使用lazy参数来禁用这一行为.



​	复用一个已存在的对象实例:

​	如果你已经拥有一个对象实例并且想暴露出它, 你应当使用一个provider      	的.value构造函数.

​	如果你没有这么做, 那么在你调用对象的dispose方法时, 他可能仍然在使用

​	

	- 使用 来提供一个已存在的CN
	- 不要使用默认的构造函数来复用一个已存在的CN



### 读取一个值

读取一个值最简单的方式就是使用BuildContext上的扩展属性.

- 这一方法使得widget会监听T上发生的改变
- 直接返回T, 而不去监听
- 允许widget只监听T上的一部分(R)



或者使用 这一静态方法, 它的表现类似watch,并且在你为listen参数传入false时(如), 它的表现类似于read.

值得注意的是, read方法不会在值变化时使得widget重新构建, 并且不能在 内调用. 在另外一个方面来说, 它可以在除了这两个方法以外的任意之处调用.

这些方法会与传入的BuildContext关联的widget开始, 查找widget树, 并返回查找到的最近的类型T的变量.

值得注意是这一操作的复杂度是O(1), 它实际上并不涉及遍历整个组件树.

结合上面第一个暴露值的例子, 这个widget会读取暴露出的字符串并渲染.

或者不使用这些方法, 我们也可以使用 与 .

这些往往在性能优化以及当很难获取到provider的构建上下文后代时是很有用的.



### MultiProvider

当在大型应用中注入许多状态时, Provider很容易变得耦合

​    

以上两个例子的行为是一致的, MP唯一改变的就是代码书写.



### PP

从3.0.0开始, 我们提供了一种新的provider

PP能够将多个来自于其他的providers的值聚合为一个新对象, 并且将结果发送给Provider.

这个新对象会在其依赖的任一providers更新后被更新

下面的例子使用PP, 基于来自于另一个provider的counter以构建转化.

这个例子还有多种变化:

- 类名后的数字是PP依赖的其他providers的数量
  - PP VS CNPP VS LPP 它们工作的方式是相似的, 但CNPP会将它的值传递给CNP 而非 Provider



### FAQ

#### 我是否能查看我的对象的内容?

Flutter提供的开发者工具能够展示特定时刻下的widget树, 既然providers同样是widget, 他们同样能通过开发者工具进行查看.



点击一个provider, 即可查看它暴露出的值:



以上的开发者工具截图来自于example/下的示例



#### 开发者工具只显示"Instance of MyClass", 我能做什么?

默认情况下, 开发者工具基于`toString`, 也就使得默认结果是"Instance of MyClass".

如果要得到更多信息, 你有两种方式:

- 使用Flutter提供的 API

  在大多数情况下, 只需要在你的对象上使用 即可, 以下是一个自定义[debugFillProperties](https://api.flutter.dev/flutter/foundation/DiagnosticableTreeMixin/debugFillProperties.html)实现的例子:

- 重写`toString`方法

  如果你无法使用 (比如你的类在一个不依赖于Flutter的包中), 那么你可以通过重写 方法来达成效果.
  
  这比使用 x要更简单, 但能力也略有不足: 你无法展开/折叠 你的对象内部细节.
  

#### 在获得initState内部的Providers时发生了异常, 该做什么?

这个异常的出现是因为你在尝试监听一个来自于永远不会再次被调用的生命周期的provider.

这意味着你要么使用另外一个生命周期(`build`), 要么显式指定你并不在意后续更新.

也就是说, 不应该这么做

你可以这么做



这会且只会在value变化时打印value



或者你也可以这么做:



这样只会打印一次value, 并且忽视后续的更新



#### 如何控制我的对象上的热更新?

你可以使你提供的对象实现



通常会和provider一同使用



#### 使用, 在更新时出现了异常, 发生了什么?

这通常是因为你在widget树正在构建时从CN的某个后代更改了CN, 最典型的情况是在future被保存在notifier内部时发起http请求.



这是不被允许的, 因为更改会立即生效.

也就是说, 一些widget可能在变更发生前构建, 而有些则可能在构建后. 这可能造成UI不一致, 因此是被禁止的.

所以, 你应该在一个整个widget树所受影响相同的位置执行变更:

- 直接在你的model的provider/constructor的create方法内调用

  在没有形参的情况下, 这是相当有用的.

- 在框架的末尾异步的执行(Future.microtask)

  这可能不是太理想的使用方式, 但它允许你向变更传递参数

#### 我必须为复杂状态使用CN吗?

不.

你可以使用任意对象来表示你的对象, 举例来说, 一个可选的架构方案是使用Provider.value配合statefulWidget

这是一个使用这种架构的计数器示例



我们可以通过这样来读取状态:



并且这样来修改状态



或者你还可以自定义provider.



#### 我可以创建自己的Provider吗?

可以, provider暴露出了所有构建功能完备的provider所需的组件, 它包含:

- , 使任意widget能够与MP协作, 这个接口被暴露为 的一部分
- IP, 在执行  时可获取的IW

这里有个使用 作为状态的自定义provider例子:



#### 我的widget重构建太频繁了, 我能做什么?

你可以使用 而非 来指定只监听对象的部分属性:



这可能导致在除了other以外的属性发生变化时widget重构建



你可以使用 来只监听name属性



这样, 这widget间就不会在除了name以外的属性变化时进行不必要的重构建了.

同样, 你也可以使用C/S, 可选的child参数使得widget树中只有特殊的一部分会重构建



在这个示例中, 只有Bar会在A更新时重构建, Foo与Baz不会.



#### 我能使用相同类型来获得两个不同的provider吗?

不. 当你有两个持有相同类型的不同provider时, 一个widget只会获取其中的一个: 最近的一个.

你必须为显式两个provider提供不同类型, 而不是

推荐的写法:



#### 我能消费一个接口并且提供一个实现吗?

能, 类型提示(type hint)必须被提供给编译器, 来执指定挥会被消费的接口, 同时需要在craete中提供实现



#### 现有的providers

provider中提供了几种不同类型的provider供不同类型的对象使用.

完整的可用列表如下:

P 最基础的provider组成, 接收一个值并暴露它而无论值是什么.

LP 供可监听对象使用的特殊provider, LP会监听对象, 并在监听器被调用时更新依赖此对象的widgets.

CNP 供CN使用的LP规范, 会在需要时自动调用CN.dispose

VLP 监听CL, 并且只暴露出.value

SP 监听流, 并暴露出最新的值

FP 接收一个Future并在其进入complete状态时更新依赖它的组件

  